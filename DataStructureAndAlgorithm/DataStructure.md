[TOC]


# 哈希表/散列表
## 如何处理散列冲突？

> [python开发面经收集加自己的面经](https://blog.csdn.net/weixin_38104825/article/details/82596405)

1. 开放定址法
    - 线性探测法：就是一旦冲突了就放到下一个位置就好了，只要存储空间够大总会有位置放的（但是这样会产生堆积，因为他可能会把其他的原来属于别人的位置只是暂时空着的给占了）
    - 二次探测法：冲突了就放在1或者2或者3等等的平方后的位置，而不是像前面那样就是单纯的不停地加1，这样就可以不让关键字对集中在一块地方
    - 随机探测法：用一个种子产生一个随机数来作为位移量来避免冲突，然后最后查找这个数在不在的时候也用这个种子生成随机数来找
2. 再散列函数法：准备多个散列函数，这个冲突了就换下一个，总会有一个能解决冲突的
3. 链地址法：把冲突的放在一个单链表中，冲突的就串在一起就好了
4. 公共溢出区法：把冲突的放在另一个数组中，然后以后查找的时候没找到还要在这个数组中顺序查找一遍



# 树

## B树，B+树，红黑树
> [[Data Structure] 数据结构中各种树](https://www.cnblogs.com/maybe2030/p/4732377.html)

AVL树定义：AVL树是最先发明的自平衡二叉查找树。AVL树得名于它的发明者 G.M. Adelson-Velsky 和 E.M. Landis，他们在 1962 年的论文 "An algorithm for the organization of information" 中发表了它。在AVL中任何节点的两个儿子子树的高度最大差别为1，所以它也被称为高度平衡树，n个结点的AVL树最大深度约1.44log2n。查找、插入和删除在平均和最坏情况下都是O(logn)

AVL旋转比较耗时。

红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制的一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:
- 性质1. 节点是红色或黑色。
- 性质2. 根是黑色。
- 性质3. 所有叶子都是黑色（叶子是NIL节点）。
- 性质4. 每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。)
- 性质5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

红黑树最多两次调整。

红黑树插入：首先以二叉查找树的方法增加节点并标记它为红色。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整。




